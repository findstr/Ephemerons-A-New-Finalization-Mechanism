# Ephemerons:一种新的清理机制(Ephemerons:A New Finalization Mechanism)


----------

- 作者：Barry Hayesl
- 译者：[重归混沌](http://blog.gotocoding.com)

## 摘要

*Finalization*发生在垃圾回收器通知应用程序一个对象“近似可回收”的时候。它被用来帮助应用程序维持不变性。为了使finalization更有用，这篇论文从一类叫做*ephemerons*的对象的角度定义了'近似可回收'。Ephemerons与weak pairs相似，但是一个在ephemeron的key字段中的对象可能会被归类为'近似可回收'， 即使它（这个key字段)从ephemeron中的value字段可达。

## 关键字

垃圾回收，清理，弱指针，资源管理

## 介绍

从早期的Lisp系统开始，带有垃圾回收的语言都有热情的追随者，并且至少从20世纪80年代早期[RAM84，Xer85]开始，*弱引用*的形式就已经出现在这些语言周围。弱引用允许回收器释放特定的对象，即使有一些记录指针指向他们，比如将会出现的对象缓存或属性关联。

当*finalization*被添加到回收器时，需要特定类型清理活动的对象将会在释放时受益。*finalization*仅需要在特定对象被回收时，回收器通知应用程序即可[Rov85,Par90]。

## 导读

在本论文中，我们首先讨论了垃圾回收,然后通过重点分析使用*finalization*管理外部资源来展开更详细的讨论。使用特定类型的*finalization*，涉及*不可复活*的回收器，我们展示一个问题，这些需要清理的对象被他们自身的*finalization*所需要信息中的指针不恰当的持有。

这个问题的一个变种，与复活无关，随后在通过弱引用实现的*属性表*中演示。仅基于属性表的外部主义，简单的将一个对象与一个属性相关联就足以阻此它被回收。在垃圾回收社区这些问题都是众所周知的，但是似乎并没有在什么著作中被讨论过。

最终，我们引入*ephemerons*作为weak pairs的一个变种, 一个使用弱引用的传统结构，并展示垃圾回收器如何跟踪*ephemerons*来解决上存在的问题。一个*ephemeron*相关的垃圾回收器的实现伪码在论文的结尾给出。

可以查看Paul Wilson优秀的调查文章[Wil92]，对单处理器垃圾回收及自动内存管理有一个综合。查看[Hay92]来对*finalization*进行了解。

## 声明

本文作者不是*ephemeron*的发明者。George Bosworth发明了*ephemerons*并且设计了本论文呈现的算法。

## 垃圾回收

动态垃圾回收语言避免了许多必须显式释放内存所产生的常见错误。在一些场景下，显式释放可能会更有效、清晰、简单，但是垃圾回收正在变得越来越普遍.

本文呈现的内容可以在引用计数垃圾回收器中被实现，但并不是非常容易。之后所有的讨论都将会假设垃圾回收器是跟踪回收器的一些变种，可能是分代垃圾回收器[FY69,LH83], 和保守垃圾回收器[BW88]。

一种观点，垃圾回收器的目的是提供关于对象如何相互连接的全局性信息。一般情况下，它被用来定位和释放从根对象不可达的一些特定的对象集合中的对象。

在垃圾回收器作为拓扑信息来源的观点中，很自然的询问提供的这些信息能够驱动些什么其他的服务。与简单的垃圾回收一样，信息可以通过其他机制收集，比如引用计数[Col60,DB76]。本次讨论将会假设回收器是拓扑的惟一来源，目标是找到需要作为垃圾回收器需要相同类别的全局拓扑视图的其他服务。换句话说，我们正在寻找像引用计数一样可以解决问题的方案，并试试看是否可以用垃圾回收的内存遍历代替。

## FINALIZATION

当垃圾回收器可以处理不需要对象释放时，有些情况，垃圾回收器提供的更多帮助可以应用程序设计者的生活更容易。

可以通过*finalization interface（finalization接口)*来扩展垃圾回收器向应用程序提供信息，使应用程序可以知道一个感兴趣的对象什么时候变成'近似可回收'。*finalization*接口的精确定义与‘近似可回收'的定义有直接联系。（在现在回收器中，不是所有的不可达对象和’近似可回收‘对象都可以被每次回收检测到。由于保守指针的存在，数值必须被当作指针，所以这是可能发生，分代垃圾也一样，并不是回收的任何时刻都可以对所有的对象targeted。对于一些特定不可达的对象，回收器可能会假设他们可达，并且不可达和’近似可达'的对象可能会被回收器当作活着的对象。Finalization并不是及时的，因为一个finalization动作可能会在使对象变成‘近似可收集'的事件结束很久以后触发。)

一个规范的例子中，*finalization*在处理外部分配资源的**代理**对象时是有用的，比如操作系统提供的文件。在这种情况下，操作系统有一个它期望该文件的用户遵守的协议：打开文件，读写文件，然后关闭文件。

如果垃圾回收器简单的丢弃代表该系统资源的**代理**对象，协议就不能被严格遵守，因为在文件关闭以前，**代理**可能会被丢弃。这可能导至未清空的（unflushed)的缓冲区，文件可能对其他进程不可用，甚至可能会导致操作系统耗尽与打开文件相关的资源。

如果**代理**对象有某种特殊性，垃圾回收器可以被修改成，当一个准备被回收并关闭的文件，在它的**代理**内存被释放之前发出通知。一些Lisp系统已经明确允许文件有此行为[AAB+91,RAM84]，但是并没有让它可以普遍的对其他应用程序对象可用。

本文中的机制是*基于容器清理(container-based finalization)*的一个变种(与*基于对象清理(object-based finalization*相反。可以在java中见到，一个简单的对象清理形式，当**代理**不可从根部不可达时，回收器会安排**代理**收到一条特殊的消息[GJS96]。这也通常使他们再次可达.)在这些模式中，**代理**对象被特殊对待，不是因为他们自身的任何特性，而是因为他们在一种可以被垃圾回收器识别的特殊类型的容器内。

例如：为了确保所有文件在被应用程序用完以后都能被关闭，文件管理器需要维护一个特殊的‘打开文件容器'，此容器可以被回收器和文件管理器感知，但是并不被文件管理器的客户端所感知。当每一个文件被第一次打开时，文件管理器可以把此文件**代理**放入容器内，并将**代理**的指针返回给正在打开文件的客户端。

只要有一个客户端还在使用这个文件，除了打开文件容器中的指针外，还会有一个指针指向**代理**。当客户端删掉最后一个指向**代理**的指针后，文件管理器的打开文件容器依然将会有一个指针指向**代理**。如果管理器知道**代理**是‘近似可回收’的，通过这个定义，它可以知道关闭文件并释放资源，并且可以回收**代理**。

这正是垃圾回收器能够发现并通信的全局拓扑信息。

## 问题

'近似可回收'对象有两个行为，一是运行特定的代码来释放系统资源，另一个是释放**代理**。部分回收器持有一种观点，**代理**应该在通知应用程序之前被回收。在特殊容器中指向**代理**的指针被替换成某种特殊的*墓碑(可能是一个空指针)*来避免野指针指向已释放的**代理**。一旦墓碑被放置，就没有指针指向对象，它就可以被释放了。直到那时应用程序将会被通知。由于‘近似可回收’对象在应用程序被通知以前就已经回收了，这可以避免‘近似可回收’**代理***被复活*（一个不可复活的回收器被期望可以更容易的形成和检查一些不变量，但是这个观点并不是普遍的)。

在打开文件的例子中，**代理**在文件管理器被通知此**代理**是‘近似可回收’之前，就已经被不可复活垃圾回收器给释放了。由于文件管理器收到通知‘**代理**被回收’的同时，代理已经被释放了，因此关闭文件所需要的信息（例如，文件ID）必须与代理本身进行分隔开。贯穿资源整个生命周期的信息，被分解成**代理**和*执行者*, **执行者**保存当代理被回收之后所需要的信息。

**代理**被垃圾回收器所知晓，是代理一些外部资源的内部对象。**执行者**并不被垃圾回收器知晓，但是他是一个，用于保存当**代理**被回收以后，用来**清理(finalization)**外部资源所需的信息的惯用名称。

在大多数情况下，这种分解是简单的，一个可以被它自己的**执行者**使用，关于它自身的影子复制即可。但是，如果对象包含了一个指向它自身的指针，**执行者**以一个指向proxy的指针而结束，只要**执行者**可达，代理就永远不可能成为‘近似可回收’。从**执行者**到**代理**的路径不需要很短--任何间接导致**代理**指向他自己，都会引起一条从**执行者**到**代理**的路径并阻碍*清理（finalization)*。

**代理**和**执行者**的分解可能会很复杂。如果有两个*可清理(finalizable)*对象，一个对象的**执行者**与另一个对象的**代理**相互引用，可能会相互阻止对方被回收。分解要想避免这种情况，就需要更多的全局知识，这些知识可以很容易的通过接口表现出来，由于接口通常并不会表明一个对象是一个外部资源的**代理**, 这将需要**可清理（finalizable)**对象的清理循环，这将会出现本文讨论范围之外的困难(当一组指向彼此的可清理对象都被发现‘近似可收集’，没有一致协议来解决这个问题，如果有应该被告知。困难之处在于，在清理时，一个可能需要另一个，如果选择一个不适当的顺序，就可会发现需要的对象可能已经被清理掉了。当在对象的连通性中存在一个环，回收器需要额外的信息来作一个合理的决定。*守护者(Guardians)*[DBE93]试图提供这一信息，但是这种方式还没有被广泛接受）。

只有不可复活的回收器强制执行**代理**和**执行者**的分析。在一个不将特殊容器中的指针替换为墓碑的回收器中，**代理**和**执行者**可以被合并。

与**代理**和**执行者**相关的问题，与不可复活的回收器也相关。有一个更一般的涉及‘近似可回收’对象的循环引用的问题，此问题存在于任何支持容器清理(finalization)的回收器中：释放属性表中的对象。 
